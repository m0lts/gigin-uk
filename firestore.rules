rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    /* ===========================
     * Users
     * =========================== */
    match /users/{userId} {
      // Only the authenticated owner can read their own user doc
      allow read: if request.auth != null && request.auth.uid == userId;

      allow create: if request.auth != null
        && request.auth.uid == userId
        && !request.resource.data.keys().hasAny([
          'stripeCustomerId',
          'stripeConnectId',
          'stripeAccountId',
          'withdrawableEarnings',
          'venueProfiles',
          'musicianProfile',
          'bands',
          'createdAt'
        ]);

      // Allow the owner to update limited, user-facing fields only
      allow update: if request.auth != null
        && request.auth.uid == userId
        && !(
          request.resource.data
            .diff(resource.data)
            .affectedKeys()
            .hasAny([
              // Server-only fields (cannot be touched by client)
              'stripeCustomerId',
              'stripeConnectId',
              'stripeAccountId',
              'withdrawableEarnings',
              'venueProfiles',
              'musicianProfile',
              'bands',
              'createdAt',
              'primaryArtistProfileId',
              'primaryProfileSet',
            ])
        );

      // Never allow client deletion of user docs
      allow delete: if false;
    }

    /* ===========================
     * Venue Profiles (+ members)
     * =========================== */
    match /venueProfiles/{venueId} {
      allow read: if true;

      allow create: if request.auth != null
        && request.resource.data.createdBy == request.auth.uid;
        
      allow update: if request.auth != null
        && (
          resource.data.createdBy == request.auth.uid ||
          // member doc exists under this venue with id == user uid
          exists(/databases/$(database)/documents/venueProfiles/$(venueId)/members/$(request.auth.uid))
        );

      allow delete: if request.auth != null
        && resource.data.createdBy == request.auth.uid;

      match /members/{memberId} {
        // Only creator can create/modify members for now
        allow create, update, delete: if request.auth != null
          && get(/databases/$(database)/documents/venueProfiles/$(venueId)).data.createdBy == request.auth.uid;

        // Read: creator OR the member themself
        allow read: if request.auth != null && (
          get(/databases/$(database)/documents/venueProfiles/$(venueId)).data.createdBy == request.auth.uid
          || request.auth.uid == memberId
        );
      }
    }

    /* ===========================
     * Venue Invites / Requests / Templates
     * =========================== */
     
    function isVenueOwnerTop(uid, venueId) {
      let v = get(/databases/$(database)/documents/venueProfiles/$(venueId)).data;
      return v.createdBy == uid || v.userId == uid; // support either field if present
    }

    function isActiveVenueMemberTop(uid, venueId) {
      let memberPath = /databases/$(database)/documents/venueProfiles/$(venueId)/members/$(uid);
      return exists(memberPath) && get(memberPath).data.status == "active";
    }
     
    match /venueInvites/{inviteId} {
      allow read: if true;
      allow create: if request.auth != null
        && isVenueOwnerTop(request.auth.uid, request.resource.data.venueId);
      allow update, delete: if request.auth != null
        && isVenueOwnerTop(request.auth.uid, resource.data.venueId);
    }

    match /venueRequests/{requestId} {
      // Read if caller is venue owner OR an active member of that venue
      allow read: if request.auth != null
        && (
          isVenueOwnerTop(request.auth.uid, resource.data.venueId) ||
          isActiveVenueMemberTop(request.auth.uid, resource.data.venueId)
        );

      // Writes still limited to venue owner (as before)
      allow update: if request.auth != null
        && isVenueOwnerTop(request.auth.uid, resource.data.venueId);
        
      allow create: if request.auth != null;
      allow delete: if false;
    }

    match /templates/{templateId} {
      // Read if caller is venue owner OR an active member of that venue
      allow read: if request.auth != null
        && (
          isVenueOwnerTop(request.auth.uid, resource.data.venueId) ||
          isActiveVenueMemberTop(request.auth.uid, resource.data.venueId)
        );

      // Create/Update stays owner-only (using the incoming doc's venueId)
      allow create, update: if request.auth != null
        && isVenueOwnerTop(request.auth.uid, request.resource.data.venueId);

      // Delete stays owner-only (using the stored doc's venueId)
      allow delete: if request.auth != null
        && isVenueOwnerTop(request.auth.uid, resource.data.venueId);
    }

    /* ===========================
     * Reviews / Disputes / Feedback
     * =========================== */
    match /reviews/{reviewId} {
      allow read: if true;                  // public
      allow create, update, delete: if false; // CF only
    }

    match /disputes/{disputeId} {
      // Only participants can read their dispute
      allow read: if request.auth != null
        && resource.data.participants != null
        && resource.data.participants.hasAny([request.auth.uid]);

      // No client writes—use Cloud Functions
      allow create, update, delete: if false;
    }

    match /feedback/{feedbackId} {
      // Any authenticated user can read and submit
      allow read, create: if request.auth != null;

      // Prevent client edits/deletes of existing feedback
      allow update, delete: if false;
    }

    /* ===========================
     * Payments
     * =========================== */
    match /payments/{paymentId} {
      // Only the payer or recipient can read
      allow read: if request.auth != null
        && (resource.data.payerUid == request.auth.uid
            || resource.data.recipientUid == request.auth.uid);

      // All writes via webhooks / CF
      allow create, update, delete: if false;
    }

    /* ===========================
     * Musician Profiles (+ fees)
     * =========================== */
    match /musicianProfiles/{musicianId} {
      // Signed-in users can read musician profiles
      allow read: if request.auth != null;

      // Create must belong to caller
      allow create: if request.auth != null
        && request.resource.data.userId == request.auth.uid;

      // Update: only owner; block financial/server-only fields and userId
      allow update: if request.auth != null
        && resource.data.userId == request.auth.uid
        && !(
          request.resource.data
            .diff(resource.data)
            .affectedKeys()
            .hasAny([
              'withdrawableFunds',
              'withdrawableEarnings',
              'pendingFeesTotal',
              'clearedFeesTotal',
              'userId'
            ])
        );

      // Delete: only owner
      allow delete: if request.auth != null
        && resource.data.userId == request.auth.uid;

      // ----- pendingFees subcollection -----
      match /pendingFees/{feeId} {
        function isOwner() {
          return request.auth != null
            && get(/databases/$(database)/documents/musicianProfiles/$(musicianId)).data.userId == request.auth.uid;
        }

        // Only owner can read their pending fees
        allow read: if isOwner();

        // CF/webhook only
        allow create, delete: if false;

        // Owner can mark "in dispute" without touching amounts/times/etc.
        allow update: if isOwner()
          && !(
            request.resource.data
              .diff(resource.data)
              .affectedKeys()
              .hasAny(['amount','gigId','payoutId','clearingTime','createdAt'])
          )
          && request.resource.data.status == 'in dispute'
          && request.resource.data.disputeLogged == true;
      }

      // ----- clearedFees subcollection -----
      match /clearedFees/{feeId} {
        function isOwner() {
          return request.auth != null
            && get(/databases/$(database)/documents/musicianProfiles/$(musicianId)).data.userId == request.auth.uid;
        }

        // Only owner can read
        allow read: if isOwner();

        // CF/webhook only
        allow create, update, delete: if false;
      }
    }

    /* ===========================
     * Artist Profiles Helper Functions
     * =========================== */
    
    // Helper function to check if user is the owner of an artist profile
    function isArtistProfileOwner(uid, artistProfileId) {
      return request.auth != null
        && uid == request.auth.uid
        && get(/databases/$(database)/documents/artistProfiles/$(artistProfileId)).data.userId == uid;
    }

    // Helper function to check if user is an active member with a specific permission
    function hasArtistProfilePermission(uid, artistProfileId, permissionKey) {
      return request.auth != null
        && uid == request.auth.uid
        && (
          // Owner always has all permissions
          get(/databases/$(database)/documents/artistProfiles/$(artistProfileId)).data.userId == uid
          || (
            // Check member permissions
            exists(/databases/$(database)/documents/artistProfiles/$(artistProfileId)/members/$(uid))
            && get(/databases/$(database)/documents/artistProfiles/$(artistProfileId)/members/$(uid)).data.status == "active"
            && get(/databases/$(database)/documents/artistProfiles/$(artistProfileId)/members/$(uid)).data.permissions != null
            && get(/databases/$(database)/documents/artistProfiles/$(artistProfileId)/members/$(uid)).data.permissions[permissionKey] == true
          )
        );
    }

    // Helper function to check if user is an active member (any permission)
    function isActiveArtistProfileMember(uid, artistProfileId) {
      return request.auth != null
        && uid == request.auth.uid
        && (
          // Owner is always a member
          get(/databases/$(database)/documents/artistProfiles/$(artistProfileId)).data.userId == uid
          || (
            // Check if active member exists
            exists(/databases/$(database)/documents/artistProfiles/$(artistProfileId)/members/$(uid))
            && get(/databases/$(database)/documents/artistProfiles/$(artistProfileId)/members/$(uid)).data.status == "active"
          )
        );
    }

    /* ===========================
     * Artist Profiles (+ members)
     * =========================== */
    match /artistProfiles/{artistProfileId} {
      // Public read access for artist profiles (for discovery)
      allow read: if true;

      // Create: authenticated users only, and userId must match caller
      allow create: if request.auth != null
        && request.resource.data.userId == request.auth.uid
        && !request.resource.data.keys().hasAny([
          'createdAt',
          'updatedAt'
        ]);

      // Update: owner OR active member with 'profile.edit' permission
      // Block server-only fields: userId, createdAt, updatedAt
      allow update: if request.auth != null
        && (
          isArtistProfileOwner(request.auth.uid, artistProfileId) ||
          hasArtistProfilePermission(request.auth.uid, artistProfileId, 'profile.edit')
        )
        && !(
          request.resource.data
            .diff(resource.data)
            .affectedKeys()
            .hasAny([
              'userId',
              'createdAt'
            ])
        )
        // Allow updatedAt to be set, but it should be server timestamp in practice
        && (
          !request.resource.data.keys().hasAny(['updatedAt']) ||
          request.resource.data.updatedAt is timestamp
        );

      // Delete: only owner (prefer CF for coordinated cleanup)
      allow delete: if isArtistProfileOwner(request.auth.uid, artistProfileId);

      // Members subcollection
      match /members/{memberId} {
        // Public read access for members (anyone can see who's in a band/artist profile)
        allow read: if true;

        // Create: owner OR active member with 'profile.edit' permission
        allow create: if request.auth != null
          && (
            isArtistProfileOwner(request.auth.uid, artistProfileId) ||
            hasArtistProfilePermission(request.auth.uid, artistProfileId, 'profile.edit')
          )
          && request.resource.data.userId is string
          && !request.resource.data.keys().hasAny([
            'createdAt',
            'updatedAt'
          ]);

        // Update: 
        // - Owner can update any member
        // - Member with 'profile.edit' can update any member
        // - Member can update their own record (limited fields: status, permissions if they have profile.edit)
        allow update: if request.auth != null
          && (
            // Owner can update anyone
            isArtistProfileOwner(request.auth.uid, artistProfileId) ||
            // Member with profile.edit can update anyone
            hasArtistProfilePermission(request.auth.uid, artistProfileId, 'profile.edit') ||
            // Member can update their own record (limited)
            (request.auth.uid == memberId && 
             // Only allow updating status, and only to 'inactive' (can't reactivate themselves)
             request.resource.data.diff(resource.data).affectedKeys().hasOnly(['status']) &&
             request.resource.data.status == 'inactive')
          )
          && !(
            request.resource.data
              .diff(resource.data)
              .affectedKeys()
              .hasAny([
                'userId',
                'addedBy',
                'createdAt'
              ])
          )
          && (
            !request.resource.data.keys().hasAny(['updatedAt']) ||
            request.resource.data.updatedAt is timestamp
          );

        // Delete: owner OR member with 'profile.edit' permission
        // Note: Members can't delete themselves (they should set status to 'inactive')
        allow delete: if request.auth != null
          && (
            isArtistProfileOwner(request.auth.uid, artistProfileId) ||
            hasArtistProfilePermission(request.auth.uid, artistProfileId, 'profile.edit')
          );
      }

      // ----- pendingFees subcollection -----
      match /pendingFees/{feeId} {
        function isOwnerOrFinancesViewer() {
          return request.auth != null
            && (
              isArtistProfileOwner(request.auth.uid, artistProfileId) ||
              hasArtistProfilePermission(request.auth.uid, artistProfileId, 'finances.edit') ||
              hasArtistProfilePermission(request.auth.uid, artistProfileId, 'profile.viewer')
            );
        }

        // Only owner or members with finances permissions can read their pending fees
        allow read: if isOwnerOrFinancesViewer();

        // CF/webhook only
        allow create, delete: if false;

        // Owner or member with finances.edit can mark "in dispute" without touching amounts/times/etc.
        allow update: if isOwnerOrFinancesViewer()
          && !(
            request.resource.data
              .diff(resource.data)
              .affectedKeys()
              .hasAny(['amount','gigId','payoutId','clearingTime','createdAt'])
          )
          && request.resource.data.status == 'in dispute'
          && request.resource.data.disputeLogged == true;
      }

      // ----- clearedFees subcollection -----
      match /clearedFees/{feeId} {
        function isOwnerOrFinancesViewer() {
          return request.auth != null
            && (
              isArtistProfileOwner(request.auth.uid, artistProfileId) ||
              hasArtistProfilePermission(request.auth.uid, artistProfileId, 'finances.edit') ||
              hasArtistProfilePermission(request.auth.uid, artistProfileId, 'profile.viewer')
            );
        }

        // Only owner or members with finances permissions can read
        allow read: if isOwnerOrFinancesViewer();

        // CF/webhook only
        allow create, update, delete: if false;
      }
    }

    /* ===========================
     * Artist Invites
     * =========================== */
    match /artistInvites/{inviteId} {
      // Read: owner OR active member with 'profile.edit' permission of the artist profile
      // OR user can read invites sent to their email
      allow read: if request.auth != null
        && resource.data.artistProfileId is string
        && (
          isArtistProfileOwner(request.auth.uid, resource.data.artistProfileId) ||
          hasArtistProfilePermission(request.auth.uid, resource.data.artistProfileId, 'profile.edit') ||
          // Allow user to read their own invite (by email match)
          (resource.data.email != null && 
           exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
           get(/databases/$(database)/documents/users/$(request.auth.uid)).data.email == resource.data.email)
        );

      // Create: owner only
      allow create: if request.auth != null
        && isArtistProfileOwner(request.auth.uid, request.resource.data.artistProfileId)
        && request.resource.data.invitedBy == request.auth.uid
        && request.resource.data.status == 'pending'
        && request.resource.data.email is string
        && request.resource.data.permissions is map;

      // Update: owner OR user accepting their own invite
      allow update: if request.auth != null
        && resource.data.artistProfileId is string
        && (
          // Owner can update any invite
          isArtistProfileOwner(request.auth.uid, resource.data.artistProfileId) ||
          // User can accept their own invite (by email match)
          (resource.data.email != null &&
           exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
           get(/databases/$(database)/documents/users/$(request.auth.uid)).data.email == resource.data.email &&
           request.resource.data.status == 'accepted' &&
           request.resource.data.acceptedBy == request.auth.uid &&
           request.resource.data.diff(resource.data).affectedKeys().hasOnly(['status', 'acceptedBy', 'acceptedAt']))
        );

      // Delete: owner only
      allow delete: if request.auth != null
        && resource.data.artistProfileId is string
        && isArtistProfileOwner(request.auth.uid, resource.data.artistProfileId);
    }

    /* ===========================
     * Gigs Helper Functions
     * =========================== */
    function isAuthed() {
      return request.auth != null;
    }

    function isVenueOwner(venueId) {
      return isAuthed()
        && get(/databases/$(database)/documents/venueProfiles/$(venueId)).data.createdBy == request.auth.uid;
    }

    function isActiveVenueMember(venueId) {
      return isAuthed()
        && exists(/databases/$(database)/documents/venueProfiles/$(venueId)/members/$(request.auth.uid));
    }

    function isVenueActor(venueId) {
      return isVenueOwner(venueId) || isActiveVenueMember(venueId);
    }

    function sensitiveGigFields() {
      return [
        'applicants',
        'agreedFee',
        'paid',
        'paymentStatus',
        'musicianFeeStatus',
        'disputeClearingTime',
        'disputeLogged',
        'clearPendingFeeTaskName',
        'automaticMessageTaskName',
        'venueId'
      ];
    }

    match /gigs/{gigId} {
      // Publicly readable
      allow read: if true;

      // CREATE: only venue owner or active member; no sensitive fields allowed at create
      allow create: if isAuthed()
        && request.resource.data.venueId is string
        && isVenueActor(request.resource.data.venueId)
        && !request.resource.data.keys().hasAny(sensitiveGigFields());

      // UPDATE: only venue owner or active member of the gig's venue
      // - may NOT change venueId
      // - may NOT touch sensitive fields
      allow update: if isAuthed()
        && isVenueActor(resource.data.venueId)
        && !(request.resource.data
              .diff(resource.data)
              .affectedKeys()
              .hasAny(sensitiveGigFields()));

      // DELETE: only venue owner (prefer CF for coordinated cleanup)
      allow delete: if isAuthed() && isVenueOwner(resource.data.venueId);
    }

    /* ===========================
     * Bands (+ members)
     * =========================== */
    match /bands/{bandId} {
      // Public profile is readable by anyone
      allow read: if true;

      // Client writes disabled — membership + admin changes via CF
      allow create, update, delete: if false;

      match /members/{memberId} {
        // Read allowed to band admin or the member themselves
        allow read: if isAuthed();

        // Membership changes via CF
        allow create, update, delete: if false;
      }
    }

    /* ===========================
     * Conversations (+ messages)
     * =========================== */
    match /conversations/{convId} {
      function convDocAuthorized() {
        return isAuthed()
          && resource.data.authorizedUserIds != null
          && resource.data.authorizedUserIds.hasAny([request.auth.uid]);
      }

      allow get, list: if convDocAuthorized();

      // Update only the caller's lastViewed.{uid}
      allow update: if convDocAuthorized()
        // Only 'lastViewed' changed at the top level
        && request.resource.data.diff(resource.data).changedKeys().hasOnly(['lastViewed'])
        // Ensure the new lastViewed is a map with a timestamp at the caller's key
        && request.resource.data.lastViewed is map
        && request.resource.data.lastViewed[request.auth.uid] is timestamp
        // If there was no lastViewed before, allow initializing; otherwise ensure only my key changed in BOTH directions.
        && (
          !resource.data.keys().hasAny(['lastViewed'])
          || (
            resource.data.lastViewed is map
            && request.resource.data.lastViewed.diff(resource.data.lastViewed).changedKeys().hasOnly([request.auth.uid])
            && resource.data.lastViewed.diff(request.resource.data.lastViewed).changedKeys().hasOnly([request.auth.uid])
          )
        );

      allow create, delete: if false;

      match /messages/{msgId} {
        function parentAuthorized() {
          return isAuthed()
            && get(/databases/$(database)/documents/conversations/$(convId)).data.authorizedUserIds.hasAny([request.auth.uid]);
        }

        allow get, list: if parentAuthorized();

        function allowedClientType() {
          return request.resource.data.type in ['text','application','negotiation','invitation'];
        }

        function allowedClientStatus() {
          return !(request.resource.data.keys().hasAny(['status'])) || request.resource.data.status in ['pending', null];
        }

        allow create: if parentAuthorized()
          && request.resource.data.senderId == request.auth.uid
          && request.resource.data.senderId != 'system'
          && allowedClientType()
          && allowedClientStatus()
          && request.resource.data.timestamp is timestamp
          && request.resource.data.keys().hasOnly([
               'senderId','text','timestamp','type','status',
               'oldFee','newFee','profileId','profileType','cancellingParty'
             ]);

        allow update, delete: if false;
      }
    }
  }
}

