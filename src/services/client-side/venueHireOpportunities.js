/**
 * Venue Hire Opportunities – Firestore collection: venueHireOpportunities
 *
 * Each document represents ONE hire opportunity for a venue on a date/time.
 * This collection is used instead of storing venue hire as "gigs" (gigs are for artist bookings only).
 *
 * Schema (minimum fields):
 * - id (doc id)
 * - venueId
 * - createdByUserId
 * - createdAt, updatedAt (Timestamp)
 * - status: 'available' | 'pending' | 'confirmed' | 'cancelled'
 * - date (Timestamp), startTime, endTime (or startDateTime/endDateTime)
 * - accessFrom?, curfew?
 * - hireFee (string e.g. "£100" to match app currency handling)
 * - depositRequired (boolean), depositAmount?, depositPaid?
 * - technicalSetup: { paIncluded, soundEngineerIncluded, ... }
 * - documents: []
 * - notesInternal (string)
 * - hirerType: 'none' | 'manual' | 'gigin_user'
 * - hirerContactId?, hirerUserId?, hirerName?
 * - performers: [{ type: 'manual'|'gigin_artist', contactId?, artistId?, name }]
 * - private (boolean) – invite-only applications
 * - linkedGigId? – set when a gig is created from this hire (on-platform confirmation)
 */

import { firestore } from '@lib/firebase';
import {
  collection,
  query,
  where,
  getDocs,
  doc,
  getDoc,
  onSnapshot,
  Timestamp,
} from 'firebase/firestore';
import * as venueHireApi from '@services/api/venueHireOpportunities';

const COLLECTION = 'venueHireOpportunities';

/**
 * Get a Firestore Timestamp for a date (Date or ISO date string or existing Timestamp).
 */
function toTimestamp(value) {
  if (!value) return null;
  if (value && typeof value.toDate === 'function') return value;
  const d = value instanceof Date ? value : new Date(value);
  return isNaN(d.getTime()) ? null : Timestamp.fromDate(d);
}

/**
 * Create a single venue hire opportunity (via API).
 * @param {Object} data – fields per schema (id will be generated by API if not provided)
 * @returns {Promise<{ id: string }>}
 */
export async function createVenueHireOpportunity(data) {
  const venueId = data.venueId;
  if (!venueId) throw new Error('venueHireOpportunities.create: venueId required');
  const res = await venueHireApi.createVenueHireOpportunitiesBatch({ venueId, items: [data] });
  const id = res?.ids?.[0] ?? null;
  if (!id) throw new Error('venueHireOpportunities.create: no id returned');
  return { id };
}

/**
 * Create multiple venue hire opportunities via API (e.g. one per date).
 * @param {Array<Object>} items – array of payloads (each must include venueId)
 * @returns {Promise<Array<{ id: string }>>}
 */
export async function createVenueHireOpportunitiesBatch(items) {
  if (!items?.length) return [];
  const venueId = items[0].venueId;
  if (!venueId) throw new Error('venueHireOpportunities.createBatch: venueId required on first item');
  const res = await venueHireApi.createVenueHireOpportunitiesBatch({ venueId, items });
  return (res?.ids ?? []).map((id) => ({ id }));
}

/**
 * Update a venue hire opportunity by id (via API).
 */
export async function updateVenueHireOpportunity(id, updates) {
  if (!id) throw new Error('venueHireOpportunities.update: id required');
  await venueHireApi.updateVenueHireOpportunity(id, updates);
}

/**
 * Get a single venue hire opportunity by id.
 * @returns {Promise<Object|null>} – { id, ...data } or null
 */
export async function getVenueHireOpportunityById(id) {
  if (!id) return null;
  try {
    const ref = doc(firestore, COLLECTION, id);
    const snap = await getDoc(ref);
    if (!snap.exists()) return null;
    return { id: snap.id, ...snap.data() };
  } catch (e) {
    console.error('[Firestore Error] getVenueHireOpportunityById:', e);
    return null;
  }
}

/**
 * Get all venue hire opportunities for the given venue IDs.
 * @param {string[]} venueIds
 * @returns {Promise<Object[]>} – array of { id, ...data }
 */
export async function getVenueHireOpportunitiesByVenueIds(venueIds) {
  try {
    if (!venueIds?.length) return [];
    const batchSize = 10;
    const out = [];
    for (let i = 0; i < venueIds.length; i += batchSize) {
      const batch = venueIds.slice(i, i + batchSize);
      const q = query(
        collection(firestore, COLLECTION),
        where('venueId', 'in', batch)
      );
      const snapshot = await getDocs(q);
      snapshot.docs.forEach((d) => out.push({ id: d.id, ...d.data() }));
    }
    return out;
  } catch (e) {
    console.error('[Firestore Error] getVenueHireOpportunitiesByVenueIds:', e);
    return [];
  }
}

/**
 * Subscribe to venue hire opportunities for the given venue IDs (upcoming + recent, similar to gigs).
 * @param {string[]} venueIds
 * @param {function(Object[]): void} callback
 * @returns {function()} – unsubscribe
 */
export function subscribeToVenueHireOpportunities(venueIds, callback) {
  if (!venueIds?.length) return () => {};
  const now = new Date();
  const pastCutoff = new Date(now.getTime() - 48 * 60 * 60 * 1000);
  const futureCutoff = Timestamp.fromDate(pastCutoff);
  const all = new Map();
  const unsubs = [];

  const handleSnapshot = (snapshot) => {
    snapshot.docChanges().forEach((change) => {
      const doc = { hireSpaceId: change.doc.id, id: change.doc.id, ...change.doc.data() };
      if (change.type === 'removed') all.delete(change.doc.id);
      else all.set(change.doc.id, doc);
    });
    callback(Array.from(all.values()));
  };

  const batchSize = 10;
  for (let i = 0; i < venueIds.length; i += batchSize) {
    const batch = venueIds.slice(i, i + batchSize);
    const ref = collection(firestore, COLLECTION);
    const futureQ = query(ref, where('venueId', 'in', batch), where('date', '>=', futureCutoff));
    const pastQ = query(ref, where('venueId', 'in', batch), where('date', '<', futureCutoff));
    unsubs.push(onSnapshot(futureQ, handleSnapshot, (e) => console.error('[Firestore] venueHireOpportunities future:', e)));
    unsubs.push(onSnapshot(pastQ, handleSnapshot, (e) => console.error('[Firestore] venueHireOpportunities past:', e)));
  }

  return () => unsubs.forEach((u) => u());
}

/**
 * Delete a venue hire opportunity via API (e.g. when user deletes from calendar).
 */
export async function deleteVenueHireOpportunity(id) {
  if (!id) return;
  await venueHireApi.deleteVenueHireOpportunity(id);
}
